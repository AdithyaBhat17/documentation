(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{411:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),p=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},b=function(e){var t=p(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,m=b["".concat(i,".").concat(u)]||b[u]||d[u]||r;return n?o.a.createElement(m,c(c({ref:t},l),{},{components:n})):o.a.createElement(m,c({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<r;l++)i[l]=n[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},83:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n(3),o=n(7),r=(n(0),n(411)),i={title:"Advanced Bloblang",sidebar_label:"Advanced",description:"Some advanced Bloblang patterns"},c={unversionedId:"guides/bloblang/advanced",id:"guides/bloblang/advanced",isDocsHomePage:!1,title:"Advanced Bloblang",description:"Some advanced Bloblang patterns",source:"@site/docs/guides/bloblang/advanced.md",slug:"/guides/bloblang/advanced",permalink:"/docs/guides/bloblang/advanced",editUrl:"https://github.com/Jeffail/benthos/edit/master/website/docs/guides/bloblang/advanced.md",version:"current",sidebar_label:"Advanced",sidebar:"docs",previous:{title:"Bloblang Methods",permalink:"/docs/guides/bloblang/methods"},next:{title:"Monitoring",permalink:"/docs/guides/monitoring"}},s=[{value:"Map Parameters",id:"map-parameters",children:[]},{value:"Walking the Tree",id:"walking-the-tree",children:[]},{value:"Message Expansion",id:"message-expansion",children:[]}],l={toc:s};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"map-parameters"},"Map Parameters"),Object(r.b)("p",null,"A map definition isn't able to formally specify input parameters:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-coffee"}),'map formating {\n  root = this\n  foo = "(%v)".format(foo)\n  bar = "(%v)".format(bar)\n}\n\nfirst = doc.apply("formating")\n\n# In:  {"doc":{"foo":"f","bar":"b","baz":"bz"}}\n# Out: {"first":{"bar":"(b)","baz":"bz","foo":"(f)"}}\n')),Object(r.b)("p",null,"However, we can still use object literals for this purpose. Imagine if we wanted a map that is the exact same as above except the pattern is ",Object(r.b)("inlineCode",{parentName:"p"},"[%v]")," instead, with the potential for even more patterns in the future. To do that we can pass an object with a field ",Object(r.b)("inlineCode",{parentName:"p"},"value")," with our target to map and a field ",Object(r.b)("inlineCode",{parentName:"p"},"pattern")," which allows us to specify the pattern to apply:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-coffee"}),'map formatting {\n  root = value\n  foo = pattern.format(value.foo)\n  bar = pattern.format(value.bar)\n}\n\nfirst = {"value":doc,"pattern":"(%v)"}.apply("formatting")\nsecond = {"value":doc,"pattern":"[%v]"}.apply("formatting")\n\n# In:  {"doc":{"foo":"f","bar":"b","baz":"bz"}}\n# Out: {"first":{"bar":"(b)","baz":"bz","foo":"(f)"},"second":{"bar":"[b]","baz":"bz","foo":"[f]"}}\n')),Object(r.b)("h2",{id:"walking-the-tree"},"Walking the Tree"),Object(r.b)("p",null,"Sometimes it's necessary to perform a mapping on all values within an unknown tree structure. You can do that easily with recursive mapping:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-coffee"}),'map unescape_values {\n  root = match {\n    this.type() == "object" => this.map_each(this.value.apply("unescape_values")),\n    this.type() == "array" => this.map_each(this.apply("unescape_values")),\n    this.type() == "string" => this.unescape_html(),\n    this.type() == "bytes" => this.unescape_html(),\n    _ => this,\n  }\n}\nroot = this.apply("unescape_values")\n\n# In:  {"first":{"nested":"foo &amp; bar"},"second":10,"third":["1 &lt; 2",{"also_nested":"2 &gt; 1"}]}\n# Out: {"first":{"nested":"foo & bar"},"second":10,"third":["1 < 2",{"also_nested":"2 > 1"}]}\n')),Object(r.b)("h2",{id:"message-expansion"},"Message Expansion"),Object(r.b)("p",null,"Expanding a message into >1 messages can be done by using Bloblang to map messages into an array and following it up with an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/unarchive"}),Object(r.b)("inlineCode",{parentName:"a"},"unarchive")," processor"),". For example, given documents of this format:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "id": "foobar",\n  "items": [\n    {"content":"foo"},\n    {"content":"bar"},\n    {"content":"baz"}\n  ]\n}\n')),Object(r.b)("p",null,"In the simple case we can simply pull ",Object(r.b)("inlineCode",{parentName:"p"},"items")," out to the root with ",Object(r.b)("inlineCode",{parentName:"p"},"root = items")," in a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/bloblang"}),Object(r.b)("inlineCode",{parentName:"a"},"bloblang")," processor")," and follow it with an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/unarchive"}),Object(r.b)("inlineCode",{parentName:"a"},"unarchive")," processor")," to expand each element into its own independent message:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    - bloblang: root = items\n    - unarchive:\n        format: json_array\n")),Object(r.b)("p",null,"However, most of the time we also need to map the elements before expanding them, and often that includes copying fields outside of our target array. We can do that with context variables:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-coffee"}),'let doc_root = this.without("items")\nroot = items.map_each($doc_root.merge(this))\n\n# In:  {"id":"foobar","items":[{"content":"foo"},{"content":"bar"},{"content":"baz"}]}\n# Out: [{"content":"foo","id":"foobar"},{"content":"bar","id":"foobar"},{"content":"baz","id":"foobar"}]\n')),Object(r.b)("p",null,"Also note that when we set ",Object(r.b)("inlineCode",{parentName:"p"},"doc_root")," we remove the field ",Object(r.b)("inlineCode",{parentName:"p"},"items")," from the target document. The full config would now be:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'pipeline:\n  processors:\n    - bloblang: |\n        let doc_root = this.without("items")\n        root = items.map_each($doc_root.merge(this))\n    - unarchive:\n        format: json_array\n')))}p.isMDXComponent=!0}}]);