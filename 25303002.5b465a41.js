(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{130:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"toc",(function(){return b})),n.d(t,"default",(function(){return u}));var a=n(3),o=n(7),r=(n(0),n(411)),s=n(415),l=n(416),c={id:"custom-metrics",title:"Custom Metrics",description:"Learn how to emit custom metrics from messages."},i={permalink:"/cookbooks/custom-metrics",source:"@site/cookbooks/custom_metrics.md",description:"Learn how to emit custom metrics from messages.",date:"2021-01-26T21:21:33.000Z",featured:!1,title:"Custom Metrics"},b=[{value:"The Basics",id:"the-basics",children:[]},{value:"Harder Example",id:"harder-example",children:[]},{value:"Combining into a Workflow",id:"combining-into-a-workflow",children:[]}],p={toc:b};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"You can't build cool graphs without metrics, and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/metrics/about/"}),"Benthos emits many"),". However, occasionally you might want to also emit custom metrics that track data extracted from messages being processed. In this cookbook we'll explore how to achieve this by configuring Benthos to pull download stats from Github, Dockerhub and Homebrew and emit them as gauges."),Object(r.b)("h2",{id:"the-basics"},"The Basics"),Object(r.b)("p",null,"Firstly, we need to target an API so let's start with the nice and simple Homebrew API, which we'll poll every 60 seconds."),Object(r.b)("p",null,"We can either do it with an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/inputs/http_client/"}),Object(r.b)("inlineCode",{parentName:"a"},"http_client")," input")," and a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/rate_limits/about/"}),"rate limit")," that restricts us to one request per 60 seconds, or we can use a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/inputs/bloblang/"}),Object(r.b)("inlineCode",{parentName:"a"},"bloblang")," input")," to generate a message every 60 seconds that triggers an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/http/"}),Object(r.b)("inlineCode",{parentName:"a"},"http")," processor"),":"),Object(r.b)(s.a,{defaultValue:"Processor",values:[{label:"With Processor",value:"Processor"},{label:"With Input",value:"Input"}],mdxType:"Tabs"},Object(r.b)(l.a,{value:"Processor",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'input:\n  bloblang:\n    interval: 60s\n    mapping: root = ""\n\npipeline:\n  processors:\n    - http:\n        url: https://formulae.brew.sh/api/formula/benthos.json\n        verb: GET\n'))),Object(r.b)(l.a,{value:"Input",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  http_client:\n    url: https://formulae.brew.sh/api/formula/benthos.json\n    verb: GET\n    rate_limit: brewlimit\n\nresources:\n  rate_limits:\n    brewlimit:\n      local:\n        count: 1\n        interval: 60s\n")))),Object(r.b)("p",null,"For this cookbook we'll continue with the processor option as it makes it easier to deploy it as a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/serverless/lambda/"}),"scheduled lambda function")," later on, which is how I'm currently doing it in real life."),Object(r.b)("p",null,"The homebrew formula API gives us a JSON blob that looks like this (removing fields we're not interested in, and with numbers inflated relative to my ego):"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n    "name":"benthos",\n    "desc":"Stream processor for mundane tasks written in Go",\n    "analytics":{"install":{"30d":{"benthos":78978979},"90d":{"benthos":253339124},"365d":{"benthos":681356871}}}\n}\n')),Object(r.b)("p",null,"This format makes it fairly easy to emit the value of ",Object(r.b)("inlineCode",{parentName:"p"},"analytics.install.30d.benthos")," as a gauge with the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/metric/"}),Object(r.b)("inlineCode",{parentName:"a"},"metric")," processor"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'http:\n  address: 0.0.0.0:4195\n\ninput:\n  bloblang:\n    interval: 60s\n    mapping: root = ""\n\npipeline:\n  processors:\n    - http:\n        url: https://formulae.brew.sh/api/formula/benthos.json\n        verb: GET\n\n    - metric:\n        type: gauge \n        name: downloads\n        labels:\n          source: homebrew\n        value: ${! json("analytics.install.30d.benthos") }\n\n    - bloblang: root = deleted()\n\nmetrics:\n  prometheus:\n    prefix: benthos\n    path_mapping: if this != "downloads" { deleted() }\n')),Object(r.b)("p",null,"With the above config we have selected the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/metrics/prometheus/"}),Object(r.b)("inlineCode",{parentName:"a"},"prometheus")," metrics type"),", which allows us to use ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://prometheus.io/"}),"Prometheus")," to scrape metrics from Benthos by polling its HTTP API at the url ",Object(r.b)("inlineCode",{parentName:"p"},"http://localhost:4195/stats"),"."),Object(r.b)("p",null,"We have also specified a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/metrics/prometheus/#path_mapping"}),Object(r.b)("inlineCode",{parentName:"a"},"path_mapping"))," that deletes any internal metrics usually emitted by Benthos by filtering on our custom metric name."),Object(r.b)("p",null,"Finally, there's also a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/bloblang/"}),Object(r.b)("inlineCode",{parentName:"a"},"bloblang")," processor")," added to the end of our pipeline that deletes all messages since we're not interested in sending the raw data anywhere after this point anyway."),Object(r.b)("p",null,"While running this config you can verify that our custom metric is emitted with ",Object(r.b)("inlineCode",{parentName:"p"},"curl"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"curl -s http://localhost:4195/stats | grep downloads\n")),Object(r.b)("p",null,"Giving something like:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-text"}),'# HELP benthos_downloads Benthos Gauge metric\n# TYPE benthos_downloads gauge\nbenthos_downloads{source="homebrew"} 78978979\n')),Object(r.b)("p",null,"Easy! The Dockerhub API is also pretty simple, and adding it to our pipeline is just:"),Object(r.b)(s.a,{defaultValue:"Diff",values:[{label:"Diff",value:"Diff"},{label:"Full Config",value:"Full Config"}],mdxType:"Tabs"},Object(r.b)(l.a,{value:"Diff",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),'           source: homebrew\n         value: ${! json("analytics.install.30d.benthos") }\n \n+    - bloblang: root = ""\n+\n+    - http:\n+        url: https://hub.docker.com/v2/repositories/jeffail/benthos/\n+        verb: GET\n+\n+    - metric:\n+        type: gauge\n+        name: downloads\n+        labels:\n+          source: dockerhub\n+        value: ${! json("pull_count") }\n+\n     - bloblang: root = deleted()\n'))),Object(r.b)(l.a,{value:"Full Config",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'http:\n  address: 0.0.0.0:4195\n\ninput:\n  bloblang:\n    interval: 60s\n    mapping: root = ""\n\npipeline:\n  processors:\n    - http:\n        url: https://formulae.brew.sh/api/formula/benthos.json\n        verb: GET\n\n    - metric:\n        type: gauge \n        name: downloads\n        labels:\n          source: homebrew\n        value: ${! json("analytics.install.30d.benthos") }\n\n    - bloblang: root = ""\n\n    - http:\n        url: https://hub.docker.com/v2/repositories/jeffail/benthos/\n        verb: GET\n\n    - metric:\n        type: gauge\n        name: downloads\n        labels:\n          source: dockerhub\n        value: ${! json("pull_count") }\n\n    - bloblang: root = deleted()\n\nmetrics:\n  prometheus:\n    prefix: benthos\n    path_mapping: if this != "downloads" { deleted() }\n')))),Object(r.b)("h2",{id:"harder-example"},"Harder Example"),Object(r.b)("p",null,"So that's the basics covered. Next, we're going to target the Github releases API which gives a slightly more complex payload that looks something like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "assets":[\n    {"name":"benthos-lambda_X.XX.X_linux_amd64.zip","download_count":543534545},\n    {"name":"benthos_X.XX.X_darwin_amd64.tar.gz","download_count":43242342},\n    {"name":"benthos_X.XX.X_freebsd_amd64.tar.gz","download_count":534565656},\n    {"name":"benthos_X.XX.X_linux_amd64.tar.gz","download_count":743282474324}\n  ]\n}\n')),Object(r.b)("p",null,"Where we have an object representing each release asset, of which we want to emit a separate download gauge. In order to do this we're going to use a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/bloblang/"}),Object(r.b)("inlineCode",{parentName:"a"},"bloblang")," processor")," to remap the payload from Github into an array of objects of the following form:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'[\n  {"source":"github","dist":"lambda_linux_amd64","download_count":543534545},\n  {"source":"github","dist":"darwin_amd64","download_count":43242342},\n  {"source":"github","dist":"freebsd_amd64","download_count":534565656},\n  {"source":"github","dist":"linux_amd64","download_count":743282474324}\n]\n')),Object(r.b)("p",null,"Then we can use an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/unarchive/"}),Object(r.b)("inlineCode",{parentName:"a"},"unarchive")," processor")," with the format ",Object(r.b)("inlineCode",{parentName:"p"},"json_array")," to expand this array into N individual messages, one for each asset. Finally, we will follow up with a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/metric/"}),Object(r.b)("inlineCode",{parentName:"a"},"metric")," processor")," that dynamically sets labels following the fields ",Object(r.b)("inlineCode",{parentName:"p"},"source")," and ",Object(r.b)("inlineCode",{parentName:"p"},"dist")," so that we have a separate metrics series for each asset type."),Object(r.b)("p",null,"A simple pipeline of these steps would look like this (please forgive the regexp):"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'http:\n  address: 0.0.0.0:4195\n\ninput:\n  bloblang:\n    interval: 60s\n    mapping: root = ""\n\npipeline:\n  processors:\n    - http:\n        url: https://api.github.com/repos/Jeffail/benthos/releases/latest\n        verb: GET\n\n    - bloblang: |\n        root = this.assets.map_each({\n          "source":"github",\n          "dist": this.name.re_replace("^benthos-?((lambda_)|_)[0-9\\\\.]+_([^\\\\.]+).*", "$2$3"),\n          "download_count": this.download_count\n        }).filter(this.dist != "checksums")\n\n    - unarchive:\n        format: json_array\n\n    - metric:\n        type: gauge\n        name: downloads\n        labels:\n          dist: ${! json("dist") }\n          source: ${! json("source") }\n        value: ${! json("download_count") }\n\n    - bloblang: root = deleted()\n\nmetrics:\n  prometheus:\n    prefix: benthos\n    path_mapping: if this != "downloads" { deleted() }\n')),Object(r.b)("p",null,"Finally, let's combine all the custom metrics into one pipeline."),Object(r.b)("h2",{id:"combining-into-a-workflow"},"Combining into a Workflow"),Object(r.b)("p",null,"Okay I'm getting bored now so let's wrap this up. The following config expands on the previous examples by configuring each API poll as a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/branch/"}),Object(r.b)("inlineCode",{parentName:"a"},"branch")," processor"),", which allows us to run them within a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/workflow/"}),Object(r.b)("inlineCode",{parentName:"a"},"workflow")," processor")," that can execute all three branches in parallel."),Object(r.b)("p",null,"The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/metric/"}),Object(r.b)("inlineCode",{parentName:"a"},"metric")," processors")," have also been combined into a single reusable resource by updating the other API calls to format their payloads into the same structure as our Github remap."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'http:\n  address: 0.0.0.0:4195\n\ninput:\n  bloblang:\n    interval: 60s\n    mapping: root = {}\n\npipeline:\n  processors:\n    - workflow:\n        meta_path: results\n        order: [ [ dockerhub, github, homebrew ] ]\n\nresources:\n  processors:\n    dockerhub:\n      branch:\n        request_map: \'root = ""\'\n        processors:\n          - try:\n            - http:\n                url: https://hub.docker.com/v2/repositories/jeffail/benthos/\n                verb: GET\n            - bloblang: |\n                root.source = "docker"\n                root.dist = "docker"\n                root.download_count = this.pull_count\n            - resource: metric.gauge\n\n    github:\n      branch:\n        request_map: \'root = ""\'\n        processors:\n          - try:\n            - http:\n                url: https://api.github.com/repos/Jeffail/benthos/releases/latest\n                verb: GET\n            - bloblang: |\n                root = this.assets.map_each({\n                  "source":"github",\n                  "dist": this.name.re_replace("^benthos-?((lambda_)|_)[0-9\\\\.]+_([^\\\\.]+).*", "$2$3"),\n                  "download_count": this.download_count\n                }).filter(this.dist != "checksums")\n            - unarchive:\n                format: json_array\n            - resource: metric.gauge\n            - bloblang: \'root = if batch_index() != 0 { deleted() }\'\n\n    homebrew:\n      branch:\n        request_map: \'root = ""\'\n        processors:\n          - try:\n            - http:\n                url: https://formulae.brew.sh/api/formula/benthos.json\n                verb: GET\n            - bloblang: |\n                root.source = "homebrew"\n                root.dist = "homebrew"\n                root.download_count = this.analytics.install.30d.benthos\n            - resource: metric.gauge\n\n    metric.gauge:\n      metric:\n        type: gauge\n        name: downloads\n        labels:\n          dist: ${! json("dist") }\n          source: ${! json("source") }\n        value: ${! json("download_count") }\n\nmetrics:\n  prometheus:\n    prefix: benthos\n    path_mapping: if this != "downloads" { deleted() }\n')))}u.isMDXComponent=!0},411:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=o.a.createContext({}),b=function(e){var t=o.a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=b(e.components);return o.a.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,i=c(e,["components","mdxType","originalType","parentName"]),p=b(n),m=a,d=p["".concat(s,".").concat(m)]||p[m]||u[m]||r;return n?o.a.createElement(d,l(l({ref:t},i),{},{components:n})):o.a.createElement(d,l({ref:t},i))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var i=2;i<r;i++)s[i]=n[i];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},412:function(e,t,n){"use strict";function a(e){var t,n,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(o&&(o+=" "),o+=n);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}t.a=function(){for(var e,t,n=0,o="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(o&&(o+=" "),o+=t);return o}},413:function(e,t,n){"use strict";var a=n(0),o=n(414);t.a=function(){var e=Object(a.useContext)(o.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},414:function(e,t,n){"use strict";var a=n(0),o=Object(a.createContext)(void 0);t.a=o},415:function(e,t,n){"use strict";var a=n(0),o=n.n(a),r=n(413),s=n(412),l=n(56),c=n.n(l),i=37,b=39;t.a=function(e){var t=e.lazy,n=e.block,l=e.defaultValue,p=e.values,u=e.groupId,m=e.className,d=Object(r.a)(),h=d.tabGroupChoices,f=d.setTabGroupChoices,g=Object(a.useState)(l),j=g[0],O=g[1],w=a.Children.toArray(e.children);if(null!=u){var y=h[u];null!=y&&y!==j&&p.some((function(e){return e.value===y}))&&O(y)}var v=function(e){O(e),null!=u&&f(u,e)},_=[];return o.a.createElement("div",null,o.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(s.a)("tabs",{"tabs--block":n},m)},p.map((function(e){var t=e.value,n=e.label;return o.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":j===t,className:Object(s.a)("tabs__item",c.a.tabItem,{"tabs__item--active":j===t}),key:t,ref:function(e){return _.push(e)},onKeyDown:function(e){!function(e,t,n){switch(n.keyCode){case b:!function(e,t){var n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()}(e,t);break;case i:!function(e,t){var n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()}(e,t)}}(_,e.target,e)},onFocus:function(){return v(t)},onClick:function(){v(t)}},n)}))),t?Object(a.cloneElement)(w.filter((function(e){return e.props.value===j}))[0],{className:"margin-vert--md"}):o.a.createElement("div",{className:"margin-vert--md"},w.map((function(e,t){return Object(a.cloneElement)(e,{key:t,hidden:e.props.value!==j})}))))}},416:function(e,t,n){"use strict";var a=n(3),o=n(0),r=n.n(o);t.a=function(e){var t=e.children,n=e.hidden,o=e.className;return r.a.createElement("div",Object(a.a)({role:"tabpanel"},{hidden:n,className:o}),t)}}}]);