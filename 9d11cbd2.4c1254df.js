(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{290:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return u})),n.d(t,"default",(function(){return p}));var a=n(3),o=n(7),r=(n(0),n(411)),c=n(415),s=n(416),i={title:"Windowed Processing"},l={unversionedId:"configuration/windowed_processing",id:"configuration/windowed_processing",isDocsHomePage:!1,title:"Windowed Processing",description:"There are many ways of performing windowed or aggregated message processing with the wide range of connectors and processors Benthos offers, but this usually relies on aggregating messages in transit with a cache or database.",source:"@site/docs/configuration/windowed_processing.md",slug:"/configuration/windowed_processing",permalink:"/docs/configuration/windowed_processing",editUrl:"https://github.com/Jeffail/benthos/edit/master/website/docs/configuration/windowed_processing.md",version:"current",sidebar:"docs",previous:{title:"Message Batching",permalink:"/docs/configuration/batching"},next:{title:"Metadata",permalink:"/docs/configuration/metadata"}},u=[{value:"Creating Batches",id:"creating-batches",children:[]},{value:"Grouping",id:"grouping",children:[]},{value:"Aggregating",id:"aggregating",children:[{value:"Flat Counter",id:"flat-counter",children:[]},{value:"Real Counter",id:"real-counter",children:[]},{value:"Custom Folding",id:"custom-folding",children:[]}]}],b={toc:u};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"There are many ways of performing windowed or aggregated message processing with the wide range of ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/about"}),"connectors and processors")," Benthos offers, but this usually relies on aggregating messages in transit with a cache or database."),Object(r.b)("p",null,"Instead, this document outlines the simplest way of performing tumbling window processing in Benthos, which is to use input level ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/configuration/batching"}),"batching"),". There are plans to eventually offer other windowing mechanisms such as hopping or sliding and these will behave similarly."),Object(r.b)("h2",{id:"creating-batches"},"Creating Batches"),Object(r.b)("p",null,"Firstly, we will need to create batches of messages ",Object(r.b)("em",{parentName:"p"},"before")," our processing stages. This batch mechanism is what creates our window of messages, which we can later process as a group."),Object(r.b)("p",null,"Some ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/inputs/about"}),"inputs")," natively support batching, otherwise we can wrap them within a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/inputs/broker"}),"broker"),":"),Object(r.b)(c.a,{defaultValue:"kafka",values:[{label:"Kafka",value:"kafka"},{label:"NATS (Broker)",value:"nats"}],mdxType:"Tabs"},Object(r.b)(s.a,{value:"kafka",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  kafka:\n    addresses: [ TODO ]\n    topics: [ foo, bar ]\n    consumer_group: foogroup\n    batching:\n      count: 50\n      period: 30s\n"))),Object(r.b)(s.a,{value:"nats",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  broker:\n    inputs:\n    - nats:\n        urls:\n        - nats://TODO\n        queue: benthos_queue\n        subject: foosubject\n    batching:\n      count: 50\n      period: 30s\n")))),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"NOTE: Batching here doesn't mean we ",Object(r.b)("em",{parentName:"p"},"have")," to output messages as a batch. After processing we can break this batch out and even re-batch with different settings if we want.")),Object(r.b)("p",null,"When a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/configuration/batching#batch-policy"}),"batching policy")," is defined at the input level it means inputs will consume messages and aggregate them until the batch is complete, at which point it is flushed downstream to your processors and subsequently your outputs."),Object(r.b)("p",null,"Tune the batch parameters to suit the size (or time interval, etc) of window you require."),Object(r.b)("h2",{id:"grouping"},"Grouping"),Object(r.b)("p",null,"Once our messages are batched we have one large but general window of messages. Depending on our use case we may wish to divide them into groups based on their contents. For that purpose we have two processor options: ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/group_by"}),Object(r.b)("inlineCode",{parentName:"a"},"group_by"))," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/group_by_value"}),Object(r.b)("inlineCode",{parentName:"a"},"group_by_value")),"."),Object(r.b)("p",null,"For example, we can break our window out into groups based on the messages Kafka key:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'pipeline:\n  processors:\n  - group_by_value:\n      value: ${! meta("kafka_key") }\n')),Object(r.b)("h2",{id:"aggregating"},"Aggregating"),Object(r.b)("p",null,"The main purpose of windowing messages is so they can be aggregated into a single message that summarises the window. For this purpose we have lots of options within Benthos, but for this guide we'll cover a select few, where each example uses ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/bloblang/about"}),"Bloblang"),"."),Object(r.b)("h3",{id:"flat-counter"},"Flat Counter"),Object(r.b)("p",null,"The easiest aggregation to perform is simply counting how many messages were within the window. This is easy to do with the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/bloblang"}),Object(r.b)("inlineCode",{parentName:"a"},"bloblang")," processor")," using the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/bloblang/functions#batch_size"}),Object(r.b)("inlineCode",{parentName:"a"},"batch_size")," function"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n  # TODO: Paste group processor here if you want it.\n\n  # Set the value of doc.count to the batch size.\n  - bloblang: |\n      root = this\n      doc.count = batch_size()\n\n      # Drop all documents except the first.\n      root = match {\n        batch_index() > 0 => deleted()\n      }\n")),Object(r.b)("h3",{id:"real-counter"},"Real Counter"),Object(r.b)("p",null,"If you have a group of structured documents containing numeric values that you wish to count then that's also pretty easy with Bloblang. For brevity we're going to assume our messages are JSON documents of the format:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{"doc":{"count":5,"contents":"foobar"}}\n')),Object(r.b)("p",null,"And that we only wish to preserve the first message of the batch. We can do this by extracting the ",Object(r.b)("inlineCode",{parentName:"p"},"doc.count")," value of each document into an array with the method ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/bloblang/methods#from_all"}),Object(r.b)("inlineCode",{parentName:"a"},"from_all"))," and adding them with the method ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/bloblang/methods#sum"}),Object(r.b)("inlineCode",{parentName:"a"},"sum")),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'pipeline:\n  processors:\n  # TODO: Paste group processor here if you want it.\n\n  - bloblang: |\n      root = this\n      doc.count = json("doc.count").from_all().sum()\n\n      # Drop all documents except the first.\n      root = match {\n        batch_index() > 0 => deleted()\n      }\n')),Object(r.b)("p",null,"This results in a document containing our aggregated count, along with the rest of the first document of the batch:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "doc": {\n    "count": 243,\n    "contents": "foobar"\n  }\n}\n')),Object(r.b)("h3",{id:"custom-folding"},"Custom Folding"),Object(r.b)("p",null,"Bloblang also has a method ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/bloblang/methods#fold"}),Object(r.b)("inlineCode",{parentName:"a"},"fold"))," which allows you to write custom folding logic for your values. Here's an example where we implement a max function for our counts:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'pipeline:\n  processors:\n  # TODO: Paste group processor here if you want it.\n\n  - bloblang: |\n      root = this\n      doc.max = json("doc.count").from_all().fold(0, match {\n        tally < value => value\n        _ => tally\n      })\n\n      # Drop all documents except the first.\n      root = match {\n        batch_index() > 0 => deleted()\n      }\n')),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/bloblang/about"}),"Bloblang")," is very powerful, and by using ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/bloblang/methods#from"}),Object(r.b)("inlineCode",{parentName:"a"},"from"))," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guides/bloblang/methods#from_all"}),Object(r.b)("inlineCode",{parentName:"a"},"from_all"))," it's possible to perform a wide range of batch-wide processing."))}p.isMDXComponent=!0},411:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),u=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=u(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},d=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),b=u(n),d=a,m=b["".concat(c,".").concat(d)]||b[d]||p[d]||r;return n?o.a.createElement(m,s(s({ref:t},l),{},{components:n})):o.a.createElement(m,s({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,c=new Array(r);c[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,c[1]=s;for(var l=2;l<r;l++)c[l]=n[l];return o.a.createElement.apply(null,c)}return o.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},412:function(e,t,n){"use strict";function a(e){var t,n,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(o&&(o+=" "),o+=n);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}t.a=function(){for(var e,t,n=0,o="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(o&&(o+=" "),o+=t);return o}},413:function(e,t,n){"use strict";var a=n(0),o=n(414);t.a=function(){var e=Object(a.useContext)(o.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},414:function(e,t,n){"use strict";var a=n(0),o=Object(a.createContext)(void 0);t.a=o},415:function(e,t,n){"use strict";var a=n(0),o=n.n(a),r=n(413),c=n(412),s=n(56),i=n.n(s),l=37,u=39;t.a=function(e){var t=e.lazy,n=e.block,s=e.defaultValue,b=e.values,p=e.groupId,d=e.className,m=Object(r.a)(),g=m.tabGroupChoices,h=m.setTabGroupChoices,f=Object(a.useState)(s),O=f[0],j=f[1],w=a.Children.toArray(e.children);if(null!=p){var y=g[p];null!=y&&y!==O&&b.some((function(e){return e.value===y}))&&j(y)}var v=function(e){j(e),null!=p&&h(p,e)},N=[];return o.a.createElement("div",null,o.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(c.a)("tabs",{"tabs--block":n},d)},b.map((function(e){var t=e.value,n=e.label;return o.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":O===t,className:Object(c.a)("tabs__item",i.a.tabItem,{"tabs__item--active":O===t}),key:t,ref:function(e){return N.push(e)},onKeyDown:function(e){!function(e,t,n){switch(n.keyCode){case u:!function(e,t){var n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()}(e,t);break;case l:!function(e,t){var n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()}(e,t)}}(N,e.target,e)},onFocus:function(){return v(t)},onClick:function(){v(t)}},n)}))),t?Object(a.cloneElement)(w.filter((function(e){return e.props.value===O}))[0],{className:"margin-vert--md"}):o.a.createElement("div",{className:"margin-vert--md"},w.map((function(e,t){return Object(a.cloneElement)(e,{key:t,hidden:e.props.value!==O})}))))}},416:function(e,t,n){"use strict";var a=n(3),o=n(0),r=n.n(o);t.a=function(e){var t=e.children,n=e.hidden,o=e.className;return r.a.createElement("div",Object(a.a)({role:"tabpanel"},{hidden:n,className:o}),t)}}}]);