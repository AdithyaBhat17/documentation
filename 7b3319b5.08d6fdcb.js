(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{254:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return u})),n.d(t,"default",(function(){return l}));var o=n(3),r=n(7),a=(n(0),n(411)),i={title:"Performance Tuning"},s={unversionedId:"guides/performance_tuning",id:"guides/performance_tuning",isDocsHomePage:!1,title:"Performance Tuning",description:"Maximising IO Throughput",source:"@site/docs/guides/performance_tuning.md",slug:"/guides/performance_tuning",permalink:"/docs/guides/performance_tuning",editUrl:"https://github.com/Jeffail/benthos/edit/master/website/docs/guides/performance_tuning.md",version:"current",sidebar:"docs",previous:{title:"Monitoring",permalink:"/docs/guides/monitoring"},next:{title:"Synchronous Responses",permalink:"/docs/guides/sync_responses"}},u=[{value:"Maximising IO Throughput",id:"maximising-io-throughput",children:[{value:"Benthos Reads Too Slowly",id:"benthos-reads-too-slowly",children:[]},{value:"Benthos Writes Too Slowly",id:"benthos-writes-too-slowly",children:[]}]},{value:"Maximising CPU Utilisation",id:"maximising-cpu-utilisation",children:[]}],c={toc:u};function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"maximising-io-throughput"},"Maximising IO Throughput"),Object(a.b)("p",null,"This section outlines a few common throughput issues and ways in which they can be solved within Benthos."),Object(a.b)("p",null,"It is assumed here that your Benthos instance is performing only minor processing steps, and therefore has minimal reliance on your CPU resource. If this is not the case the following still applies to an extent, but you should also refer to ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"#maximising-cpu-utilisation"}),"the next section regarding CPU utilisation"),"."),Object(a.b)("p",null,"Firstly, before venturing into Benthos configurations, you should take an in-depth look at your sources and sinks. Benthos is generally much simpler architecturally than the inputs and outputs it supports. Spend some time understanding how to squeeze the most out of these services and it will make it easier (or unnecessary) to tune your Benthos configuration."),Object(a.b)("h3",{id:"benthos-reads-too-slowly"},"Benthos Reads Too Slowly"),Object(a.b)("p",null,"If Benthos isn't reading fast enough from your source it might not necessarily be due to a slow consumer. If the sink is slow this can cause back pressure that throttles the amount Benthos can read. Try consuming a test feed with the output replaced with ",Object(a.b)("inlineCode",{parentName:"p"},"drop"),". If you notice that the input consumption suddenly speeds up then the issue is likely with the output, in which case ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"#benthos-writes-too-slowly"}),"try the next section"),"."),Object(a.b)("p",null,"If the ",Object(a.b)("inlineCode",{parentName:"p"},"drop")," output pipe didn't help then take a quick look at the basic configuration fields for the input source type. Sometimes there are fields for setting a number of background prefetches or similar concepts that can increase your throughput. For example, increasing the value of ",Object(a.b)("inlineCode",{parentName:"p"},"prefetch_count")," for an AMQP consumer can greatly increase the rate at which it is consumed."),Object(a.b)("p",null,"Next, if your source supports multiple parallel consumers then you can try doing that within Benthos by using a ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/components/inputs/broker"}),"broker"),". For example, if you started with:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  http_client:\n    url: http://localhost:4195/get\n    verb: GET\n")),Object(a.b)("p",null,"You could change to:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  broker:\n    copies: 4\n    inputs:\n      - http_client:\n          url: http://localhost:4195/get\n          verb: GET\n")),Object(a.b)("p",null,"Which would create the exact same consumer as before with four connections in total. Try increasing the number of copies to see how that affects the throughput. If your multiple consumers would require different configurations then set copies to ",Object(a.b)("inlineCode",{parentName:"p"},"1")," and write each consumer as a separate object in the ",Object(a.b)("inlineCode",{parentName:"p"},"inputs")," array."),Object(a.b)("p",null,"Read the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/components/inputs/broker"}),"broker documentation")," for more tips on simplifying broker configs."),Object(a.b)("p",null,"If your source doesn't support multiple parallel consumers then unfortunately your options are more limited. A logical next step might be to look at your network/disk configuration to see if that's a potential cause of contention."),Object(a.b)("h3",{id:"benthos-writes-too-slowly"},"Benthos Writes Too Slowly"),Object(a.b)("p",null,"If you have an output sink that regularly places back pressure on your source there are a few solutions depending on the details of the issue."),Object(a.b)("p",null,"Firstly, you should check the config parameters of your output sink. There are often fields specifically for controlling the level of acknowledgement to expect before moving onto the next message, if these levels of guarantee are overkill you can disable them for greater throughput. For example, setting the ",Object(a.b)("inlineCode",{parentName:"p"},"ack_replicas")," field to ",Object(a.b)("inlineCode",{parentName:"p"},"false")," in the Kafka sink can have a high impact on throughput."),Object(a.b)("p",null,"If the config parameters for an output sink aren't enough then you can try the following:"),Object(a.b)("h4",{id:"increase-in-flight-messages"},"Increase in flight messages"),Object(a.b)("p",null,"Most outputs have a field ",Object(a.b)("inlineCode",{parentName:"p"},"max_in_flight")," that allows you to specify how many messages can be in flight at the same time. Increasing this value can improve throughput significantly."),Object(a.b)("h4",{id:"send-messages-in-batches"},"Send messages in batches"),Object(a.b)("p",null,"Most outputs will send data quicker when messages are batched, this is often done automatically in the background. However, for a few outputs your batches need to be configured. Read the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/configuration/batching"}),"batching documentation")," for more guidance on how to tune message batches within Benthos."),Object(a.b)("h4",{id:"increase-the-number-of-parallel-output-sinks"},"Increase the number of parallel output sinks"),Object(a.b)("p",null,"If your output sink supports multiple parallel writers then it can greatly increase your throughput to have multiple connections configured."),Object(a.b)("p",null,"Increasing the number of parallel output sinks is similar to doing the same for input sources and is done using a ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/components/outputs/broker"}),"broker"),". The output broker type supports a few different routing patterns depending on your intention. In this case we want to maximize throughput so our best choice is a ",Object(a.b)("inlineCode",{parentName:"p"},"greedy")," pattern. For example, if you started with:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"output:\n  kafka:\n    addresses:\n      - localhost:9092\n    topic: benthos_stream\n")),Object(a.b)("p",null,"You could change to:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"output:\n  broker:\n    pattern: greedy\n    copies: 4\n    outputs:\n      - kafka:\n          addresses:\n            - localhost:9092\n          topic: benthos_stream\n")),Object(a.b)("p",null,"Which would create the exact same output writer as before with four copies in total. Try increasing the number of copies to see how that affects the throughput. If your multiple output writers would require different configurations (client ids, for example) then set copies to ",Object(a.b)("inlineCode",{parentName:"p"},"1")," and write each consumer as a separate object in the ",Object(a.b)("inlineCode",{parentName:"p"},"outputs")," array."),Object(a.b)("p",null,"Read the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/components/outputs/broker"}),"broker documentation")," for more tips on simplifying broker configs."),Object(a.b)("h4",{id:"level-out-input-spikes-with-a-buffer"},"Level out input spikes with a buffer"),Object(a.b)("p",null,"There are many reasons why an input source might have spikes or inconsistent throughput rates. It is possible that your output is capable of keeping up with\nthe long term average flow of data, but fails to keep up when an intermittent spike occurs."),Object(a.b)("p",null,"In situations like these it is sometimes a better use of your hardware and resources to level out the flow of data rather than try and match the peak throughput. This would depend on the frequency and duration of the spikes as well as your latency requirements, and is therefore a matter of judgement."),Object(a.b)("p",null,"Leveling out the flow of data can be done within Benthos using a ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/components/buffers/about"}),"buffer"),". Buffers allow an input source to store a bounded amount of data temporarily, which a consumer can work through at its own pace. Buffers always have a fixed capacity, which when full will proceed to block the input just like a busy output would."),Object(a.b)("p",null,"Therefore, it's still important to have an output that can keep up with the flow of data, the difference that a buffer makes is that the output only needs to keep up with the ",Object(a.b)("em",{parentName:"p"},"average")," flow of data versus the instantaneous flow of data."),Object(a.b)("p",null,"For example, if your input usually produces 10 msgs/s, but occasionally spikes to 100 msgs/s, and your output can handle up to 50 msgs/s, it might be possible to configure a buffer large enough to store spikes in their entirety. As long as the average flow of messages from the input remains below 50 msgs/s then your service should be able to continue indefinitely without ever blocking the input source."),Object(a.b)("h2",{id:"maximising-cpu-utilisation"},"Maximising CPU Utilisation"),Object(a.b)("p",null,"Some ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/components/processors/about"}),"processors")," within Benthos are relatively heavy on your CPU, and can potentially become the bottleneck of a service. In these circumstances it is worth configuring Benthos so that your processors are running on each available core of your machine without contention."),Object(a.b)("p",null,"An array of processors in any section of a Benthos config becomes a single logical pipeline of steps running on a single logical thread. The easiest way to create parallel processor threads is to configure them inside the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/configuration/processing_pipelines"}),"pipeline")," configuration block, where we can explicitly set any number of parallel processor threads independent of how many inputs or outputs we want to use."),Object(a.b)("p",null,"Please refer ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/configuration/processing_pipelines"}),"to the documentation regarding pipelines")," for some examples."))}l.isMDXComponent=!0},411:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return f}));var o=n(0),r=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),l=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),p=l(n),b=o,f=p["".concat(i,".").concat(b)]||p[b]||h[b]||a;return n?r.a.createElement(f,s(s({ref:t},c),{},{components:n})):r.a.createElement(f,s({ref:t},c))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=b;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);