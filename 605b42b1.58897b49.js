(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{207:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return r})),a.d(t,"metadata",(function(){return i})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return l}));var n=a(3),o=a(7),s=(a(0),a(411)),r={title:"Message Batching"},i={unversionedId:"configuration/batching",id:"configuration/batching",isDocsHomePage:!1,title:"Message Batching",description:"Benthos is able to join sources and sinks with sometimes conflicting batching behaviours without sacrificing its strong delivery guarantees. It's also able to perform powerful processing functions across batches of messages such as grouping, archiving and reduction. Therefore, batching within Benthos is a mechanism that serves multiple purposes:",source:"@site/docs/configuration/batching.md",slug:"/configuration/batching",permalink:"/docs/configuration/batching",editUrl:"https://github.com/Jeffail/benthos/edit/master/website/docs/configuration/batching.md",version:"current",sidebar:"docs",previous:{title:"Resources",permalink:"/docs/configuration/resources"},next:{title:"Windowed Processing",permalink:"/docs/configuration/windowed_processing"}},c=[{value:"Performance",id:"performance",children:[]},{value:"Grouped Message Processing",id:"grouped-message-processing",children:[]},{value:"Compatibility",id:"compatibility",children:[{value:"Shrinking Batches",id:"shrinking-batches",children:[]}]},{value:"Batch Policy",id:"batch-policy",children:[{value:"Post-Batch Processing",id:"post-batch-processing",children:[]}]}],p={toc:c};function l(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(s.b)("wrapper",Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"Benthos is able to join sources and sinks with sometimes conflicting batching behaviours without sacrificing its strong delivery guarantees. It's also able to perform powerful ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/configuration/windowed_processing"}),"processing functions")," across batches of messages such as grouping, archiving and reduction. Therefore, batching within Benthos is a mechanism that serves multiple purposes:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#performance"}),"Performance (throughput)")),Object(s.b)("li",{parentName:"ol"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#grouped-message-processing"}),"Grouped message processing")),Object(s.b)("li",{parentName:"ol"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#compatibility"}),"Compatibility (mixing multi and single part message protocols)"))),Object(s.b)("h2",{id:"performance"},"Performance"),Object(s.b)("p",null,"For most users the only benefit of batching messages is improving throughput over your output protocol. For some protocols this can happen in the background and requires no configuration from you. However, if an output has a ",Object(s.b)("inlineCode",{parentName:"p"},"batching")," configuration block this means it benefits from batching and requires you to specify how you'd like your batches to be formed by configuring a ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#batch-policy"}),"batching policy"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"output:\n  kafka:\n    addresses: [ todo:9092 ]\n    topic: benthos_stream\n\n    # Either send batches when they reach 10 messages or when 100ms has passed\n    # since the last batch.\n    batching:\n      count: 10\n      period: 100ms\n")),Object(s.b)("p",null,"However, a small number of inputs such as ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/inputs/kafka"}),Object(s.b)("inlineCode",{parentName:"a"},"kafka"))," must be consumed sequentially (in this case by partition) and therefore benefit from specifying your batch policy at the input level instead:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  kafka:\n    addresses: [ todo:9092 ]\n    topic: benthos_input_stream\n    batching:\n      count: 10\n      period: 100ms\n\noutput:\n  kafka:\n    addresses: [ todo:9092 ]\n    topic: benthos_stream\n")),Object(s.b)("p",null,"Inputs that behave this way are documented as such and have a ",Object(s.b)("inlineCode",{parentName:"p"},"batching")," configuration block."),Object(s.b)("p",null,"Sometimes you may prefer to create your batches before processing in order to benefit from ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#grouped-message-processing"}),"batch wide processing"),", in which case if your input doesn't already support ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#batch-policy"}),"a batch policy")," you can instead use a ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/inputs/broker"}),Object(s.b)("inlineCode",{parentName:"a"},"broker")),", which also allows you to combine inputs with a single batch policy:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  broker:\n    inputs:\n      - resource: foo\n      - resource: bar\n    batching:\n      count: 50\n      period: 500ms\n")),Object(s.b)("p",null,"This also works the same with ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/outputs/broker"}),"output brokers"),"."),Object(s.b)("h2",{id:"grouped-message-processing"},"Grouped Message Processing"),Object(s.b)("p",null,'One of the more powerful features of Benthos is that all processors are "batch aware", which means processors that operate on single messages can be configured using the ',Object(s.b)("inlineCode",{parentName:"p"},"parts")," field to only operate on select messages of a batch:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    # This processor only acts on the first message of a batch\n    - protobuf:\n        parts: [ 0 ]\n        operator: to_json\n        message: header.Message\n        import_path: /tmp/protos\n")),Object(s.b)("p",null,"And some processors such as ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/processors/sleep"}),Object(s.b)("inlineCode",{parentName:"a"},"sleep"))," are executed once per batch, you can avoid this behaviour with the ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/processors/for_each"}),Object(s.b)("inlineCode",{parentName:"a"},"for_each")," processor"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    # Sleep for one second for each message of a batch\n    - for_each:\n      - sleep:\n          duration: 1s\n")),Object(s.b)("p",null,"There's a vast number of processors that specialise in operations across batches such as ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/processors/group_by"}),"grouping")," and ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/processors/archive"}),"archiving"),". For example, the following processors group a batch of messages according to a metadata field and compresses them into separate ",Object(s.b)("inlineCode",{parentName:"p"},".tar.gz")," archives:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),'pipeline:\n  processors:\n    - group_by_value:\n        value: ${! meta("kafka_partition") }\n    - archive:\n        format: tar\n    - compress:\n        algorithm: gzip\n\noutput:\n  aws_s3:\n    bucket: TODO\n    path: docs/${! meta("kafka_partition") }/${! count("files") }-${! timestamp_unix_nano() }.tar.gz\n')),Object(s.b)("p",null,"For more examples of batched (or windowed) processing check out ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/configuration/windowed_processing"}),"this document"),"."),Object(s.b)("h2",{id:"compatibility"},"Compatibility"),Object(s.b)("p",null,"Benthos is able to read and write over protocols that support multiple part messages, and all payloads travelling through Benthos are represented as a multiple part message. Therefore, all components within Benthos are able to work with multiple parts in a message as standard."),Object(s.b)("p",null,"When messages reach an output that ",Object(s.b)("em",{parentName:"p"},"doesn't")," support multiple parts the message is broken down into an individual message per part, and then one of two behaviours happen depending on the output. If the output supports batch sending messages then the collection of messages are sent as a single batch. Otherwise, Benthos falls back to sending the messages sequentially in multiple, individual requests."),Object(s.b)("p",null,"This behaviour means that not only can multiple part message protocols be easily matched with single part protocols, but also the concept of multiple part messages and message batches are interchangeable within Benthos."),Object(s.b)("h3",{id:"shrinking-batches"},"Shrinking Batches"),Object(s.b)("p",null,"A message batch (or multiple part message) can be broken down into smaller batches using the ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/processors/split"}),Object(s.b)("inlineCode",{parentName:"a"},"split"))," processor:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  # Consume messages that arrive in three parts.\n  resource: foo\n  processors:\n    # Drop the third part\n    - select_parts:\n        parts: [ 0, 1 ]\n    # Then break our message parts into individual messages\n    - split:\n        size: 1\n")),Object(s.b)("p",null,"This is also useful when your input source creates batches that are too large for your output protocol:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"input:\n  aws_s3:\n    bucket: todo\n\npipeline:\n  processors:\n    - decompress:\n        algorithm: gzip\n    - unarchive:\n        format: tar\n    # Limit batch sizes to 5MB\n    - split:\n        byte_size: 5_000_000\n")),Object(s.b)("h2",{id:"batch-policy"},"Batch Policy"),Object(s.b)("p",null,"When an input component has a config field ",Object(s.b)("inlineCode",{parentName:"p"},"batching")," that means it supports a batch policy. This is a mechanism that allows you to configure exactly how your batching should work."),Object(s.b)("p",null,"Batches are considered complete and will be flushed downstream when either of the following conditions are met:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("inlineCode",{parentName:"li"},"byte_size")," field is non-zero and the total size of the batch in bytes matches or exceeds it (disregarding metadata.)"),Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("inlineCode",{parentName:"li"},"count")," field is non-zero and the total number of messages in the batch matches or exceeds it."),Object(s.b)("li",{parentName:"ul"},"A message added to the batch causes the ",Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"/docs/guides/bloblang/about"}),Object(s.b)("inlineCode",{parentName:"a"},"check"))," to return to ",Object(s.b)("inlineCode",{parentName:"li"},"true"),"."),Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("inlineCode",{parentName:"li"},"period")," field is non-empty and the time since the last batch exceeds its value.")),Object(s.b)("p",null,"This allows you to combine conditions:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"output:\n  kafka:\n    addresses: [ todo:9092 ]\n    topic: benthos_stream\n\n    # Either send batches when they reach 10 messages or when 100ms has passed\n    # since the last batch.\n    batching:\n      count: 10\n      period: 100ms\n")),Object(s.b)("h3",{id:"post-batch-processing"},"Post-Batch Processing"),Object(s.b)("p",null,"A batch policy also has a field ",Object(s.b)("inlineCode",{parentName:"p"},"processors")," which allows you to define an optional list of ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/components/processors/about"}),"processors")," to apply to each batch before it is flushed. This is a good place to aggregate or archive the batch into a compatible format for an output:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"output:\n  http_client:\n    url: http://localhost:4195/post\n    batching:\n      count: 10\n      processors:\n        - archive:\n            format: lines\n")),Object(s.b)("p",null,"The above config will batch up messages and then merge them into a line delimited format before sending it over HTTP. This is an easier format to parse than the default which would have been ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html"}),"rfc1342"),"."),Object(s.b)("p",null,"During shutdown any remaining messages waiting for a batch to complete will be flushed down the pipeline."))}l.isMDXComponent=!0},411:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return m}));var n=a(0),o=a.n(n);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var p=o.a.createContext({}),l=function(e){var t=o.a.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},b=function(e){var t=l(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},h=o.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,r=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),b=l(a),h=n,m=b["".concat(r,".").concat(h)]||b[h]||u[h]||s;return a?o.a.createElement(m,i(i({ref:t},p),{},{components:a})):o.a.createElement(m,i({ref:t},p))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,r=new Array(s);r[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,r[1]=i;for(var p=2;p<s;p++)r[p]=a[p];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"}}]);