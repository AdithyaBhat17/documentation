(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{269:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return s})),r.d(t,"metadata",(function(){return c})),r.d(t,"toc",(function(){return i})),r.d(t,"default",(function(){return p}));var a=r(3),n=r(7),o=(r(0),r(411)),s={title:"Error Handling"},c={unversionedId:"configuration/error_handling",id:"configuration/error_handling",isDocsHomePage:!1,title:"Error Handling",description:"It's always possible for things to go wrong, be a good captain and plan ahead.",source:"@site/docs/configuration/error_handling.md",slug:"/configuration/error_handling",permalink:"/docs/configuration/error_handling",editUrl:"https://github.com/Jeffail/benthos/edit/master/website/docs/configuration/error_handling.md",version:"current",sidebar:"docs",previous:{title:"Metadata",permalink:"/docs/configuration/metadata"},next:{title:"Interpolation",permalink:"/docs/configuration/interpolation"}},i=[{value:"Abandon on Failure",id:"abandon-on-failure",children:[]},{value:"Recover Failed Messages",id:"recover-failed-messages",children:[]},{value:"Logging Errors",id:"logging-errors",children:[]},{value:"Attempt Until Success",id:"attempt-until-success",children:[]},{value:"Drop Failed Messages",id:"drop-failed-messages",children:[]},{value:"Route to a Dead-Letter Queue",id:"route-to-a-dead-letter-queue",children:[]},{value:"Reject Messages",id:"reject-messages",children:[]}],l={toc:i};function p(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"It's always possible for things to go wrong, be a good captain and plan ahead."),Object(o.b)("div",{style:{textAlign:"center"}},Object(o.b)("img",{style:{maxWidth:"300px",marginBottom:"40px"},src:"/img/Blobpirate.svg"})),Object(o.b)("p",null,"Benthos supports a range of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/about"}),"processors")," such as ",Object(o.b)("inlineCode",{parentName:"p"},"http")," and ",Object(o.b)("inlineCode",{parentName:"p"},"aws_lambda")," that have the potential to fail if their retry attempts are exhausted. When this happens the data is not dropped but instead continues through the pipeline mostly unchanged, but a metadata flag is added allowing you to handle the errors in a way that suits your needs."),Object(o.b)("p",null,"This document outlines common patterns for dealing with errors, such as dropping them, recovering them with more processing, routing them to a dead-letter queue, or any combination thereof."),Object(o.b)("h2",{id:"abandon-on-failure"},"Abandon on Failure"),Object(o.b)("p",null,"It's possible to define a list of processors which should be skipped for messages that failed a previous stage using the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/try"}),Object(o.b)("inlineCode",{parentName:"a"},"try")," processor"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    - try:\n      - resource: foo\n      - resource: bar # Skipped if foo failed\n      - resource: baz # Skipped if foo or bar failed\n")),Object(o.b)("h2",{id:"recover-failed-messages"},"Recover Failed Messages"),Object(o.b)("p",null,"Failed messages can be fed into their own processor steps with a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/catch"}),Object(o.b)("inlineCode",{parentName:"a"},"catch")," processor"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    - resource: foo # Processor that might fail\n    - catch:\n      - resource: bar # Recover here\n")),Object(o.b)("p",null,"Once messages finish the catch block they will have their failure flags removed and are treated like regular messages. If this behaviour is not desired then it is possible to simulate a catch block with a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/switch"}),Object(o.b)("inlineCode",{parentName:"a"},"switch")," processor"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    - resource: foo # Processor that might fail\n    - switch:\n      - check: errored()\n        processors:\n          - resource: bar # Recover here\n")),Object(o.b)("h2",{id:"logging-errors"},"Logging Errors"),Object(o.b)("p",null,"When an error occurs there will occasionally be useful information stored within the error flag that can be exposed with the interpolation function ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/configuration/interpolation#bloblang-queries"}),Object(o.b)("inlineCode",{parentName:"a"},"error")),". This allows you to expose the information with processors."),Object(o.b)("p",null,"For example, when catching failed processors you can ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/log"}),Object(o.b)("inlineCode",{parentName:"a"},"log"))," the messages:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'pipeline:\n  processors:\n    - resource: foo # Processor that might fail\n    - catch:\n      - log:\n          message: "Processing failed due to: ${!error()}"\n')),Object(o.b)("p",null,"Or perhaps augment the message payload with the error message:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    - resource: foo # Processor that might fail\n    - catch:\n      - bloblang: |\n          root = this\n          root.meta.error = error()\n")),Object(o.b)("h2",{id:"attempt-until-success"},"Attempt Until Success"),Object(o.b)("p",null,"It's possible to reattempt a processor for a particular message until it is successful with a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/while"}),Object(o.b)("inlineCode",{parentName:"a"},"while"))," processor:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    - for_each:\n      - while:\n          at_least_once: true\n          max_loops: 0 # Set this greater than zero to cap the number of attempts\n          check: errored()\n          processors:\n            - type: catch # Wipe any previous error\n            - resource: foo # Attempt this processor until success\n")),Object(o.b)("p",null,"This loop will block the pipeline and prevent the blocking message from being acknowledged. It is therefore usually a good idea in practice to use the ",Object(o.b)("inlineCode",{parentName:"p"},"max_loops")," field to set a limit to the number of attempts to make so that the pipeline can unblock itself without intervention."),Object(o.b)("h2",{id:"drop-failed-messages"},"Drop Failed Messages"),Object(o.b)("p",null,"In order to filter out any failed messages from your pipeline you can use a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/bloblang"}),Object(o.b)("inlineCode",{parentName:"a"},"bloblang")," processor"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"pipeline:\n  processors:\n    - bloblang: root = if errored() { deleted() }\n")),Object(o.b)("p",null,"This will remove any failed messages from a batch."),Object(o.b)("h2",{id:"route-to-a-dead-letter-queue"},"Route to a Dead-Letter Queue"),Object(o.b)("p",null,"It is possible to route failed messages to different destinations using a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/outputs/switch"}),Object(o.b)("inlineCode",{parentName:"a"},"switch")," output"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"output:\n  switch:\n    cases:\n      - check: errored()\n        output:\n          resource: foo # Dead letter queue\n\n      - output:\n          resource: bar # Everything else\n")),Object(o.b)("h2",{id:"reject-messages"},"Reject Messages"),Object(o.b)("p",null,"Some inputs such as GCP Pub/Sub and AMQP support rejecting messages, in which case it can sometimes be more efficient to reject messages that have failed processing rather than route them to a dead letter queue. This can be achieved with the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/outputs/reject"}),Object(o.b)("inlineCode",{parentName:"a"},"reject")," output"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'output:\n  switch:\n    cases:\n      - check: errored()\n        output:\n          # Reject failed messages\n          reject: "Message failed due to: ${! error() }"\n\n      - output:\n          resource: bar # Everything else\n')),Object(o.b)("p",null,"When the source of a rejected message is a sequential input without support for conventional nacks, such as the Kafka or file inputs, a rejected message will be reprocessed from scratch, applying back pressure until it is successfully processed. This can also sometimes be a useful pattern."))}p.isMDXComponent=!0},411:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return h}));var a=r(0),n=r.n(a);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=n.a.createContext({}),p=function(e){var t=n.a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},u=function(e){var t=p(e.components);return n.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},d=n.a.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=p(r),d=a,h=u["".concat(s,".").concat(d)]||u[d]||b[d]||o;return r?n.a.createElement(h,c(c({ref:t},l),{},{components:r})):n.a.createElement(h,c({ref:t},l))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=d;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c.mdxType="string"==typeof e?e:a,s[1]=c;for(var l=2;l<o;l++)s[l]=r[l];return n.a.createElement.apply(null,s)}return n.a.createElement.apply(null,r)}d.displayName="MDXCreateElement"}}]);