(window.webpackJsonp=window.webpackJsonp||[]).push([[266],{343:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return c}));var a=n(3),o=n(7),r=(n(0),n(411)),i={title:"Sneak Peek at Bloblang",date:"2020-04-19T00:00:00+0100",author:"Ashley Jeffs",author_url:"https://github.com/Jeffail",author_image_url:"/img/ash.jpg",description:"An experiment in mapping languages",keywords:["benthos","bloblang","go","golang","stream processor","mapping"],tags:["Bloblang"]},s={permalink:"/blog/2020/04/18/sneak-peek-at-bloblang",source:"@site/blog/2020-04-19-sneak-peek-at-bloblang.md",description:"An experiment in mapping languages",date:"2020-04-18T23:00:00.000Z",tags:[{label:"Bloblang",permalink:"/blog/tags/bloblang"}],title:"Sneak Peek at Bloblang",readingTime:4.665,truncated:!0,prevItem:{title:"Bloblang Beta",permalink:"/blog/2020/05/10/bloblang-beta"},nextItem:{title:"Write a Benthos Plugin",permalink:"/blog/2019/08/19/write-a-benthos-plugin"}},l=[{value:"Why",id:"why",children:[{value:"JMESPath",id:"jmespath",children:[]},{value:"AWK",id:"awk",children:[]},{value:"JSON Processor",id:"json-processor",children:[]},{value:"IDML",id:"idml",children:[]}]},{value:"Features",id:"features",children:[]},{value:"Next Steps",id:"next-steps",children:[]}],p={toc:l};function c(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"For the last few weekends I've been dipping my toes in a mapping language design that I'm calling Bloblang. Bloblang is specifically designed for data queries and (eventually) structural data mappings. In Benthos version 3.12, which I'm planning to release today, you can play around with a limited feature set of Bloblang by using it in ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/configuration/interpolation"}),"function interpolations"),"."),Object(r.b)("h2",{id:"why"},"Why"),Object(r.b)("p",null,"My life has no meaning. Also, mapping is one of the most common boring tasks in stream and event processing. Given Benthos is meant to specialise in the boring and mundane it makes sense to treat mapping as a first class citizen."),Object(r.b)("p",null,"Up until now the story for mapping documents in Benthos has been to use ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/jmespath"}),"JMESPath"),", ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/awk"}),"AWK")," or a string of the general purpose ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/json"}),"JSON processors"),". Time and time again it has been made apparent that it ain't good enough for many use cases."),Object(r.b)("p",null,"I should mention at this point that there's also the option of ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://idml.io/"}),"IDML"),", and although Benthos hasn't supported it internally there is a solution to ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/subprocess"}),"running it in your pipeline"),"."),Object(r.b)("p",null,"For the last few years I've been helping users adopt these options and each time they fall short I've taken note of where the gaps are. This is an important part of the \"research\" phase for a language, but I also don't want to dwell on it. Here's an insultingly terse summary of what we currently have within Benthos."),Object(r.b)("h3",{id:"jmespath"},"JMESPath"),Object(r.b)("p",null,"The spiritual cousin of ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://stedolan.github.io/jq/"}),"jq"),", ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://jmespath.org/"}),"JMESPath")," is a great spec for mapping JSON documents, especially so when your intention is to outright replace the original document."),Object(r.b)("p",null,"However, when our goal is to preserve the majority of the existing document, and we only wish to express isolated mutations within the structure, it becomes ugly and risky. For example, changing just ",Object(r.b)("inlineCode",{parentName:"p"},"foo.bar.baz")," to ",Object(r.b)("inlineCode",{parentName:"p"},"this value")," looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'merge(@, {\n  "foo": merge(foo, {\n      "bar": merge(bar, {\n        "baz": "this value"\n      })\n  })\n})\n')),Object(r.b)("p",null,"Hopefully you don't add a typo there or miss on a ",Object(r.b)("inlineCode",{parentName:"p"},"merge"),", otherwise you're scrapping a large chunk of your original document!"),Object(r.b)("p",null,"Expressing your entire map in one single object also scales pretty poorly as the mapping grows in complexity."),Object(r.b)("p",null,"A final and Benthos specific issue is that JMESPath only supports mapping the content of Benthos messages, without the ability to modify or reference the metadata of a message or other messages of a batch, which would be great for ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/configuration/windowed_processing"}),"windowed processing"),"."),Object(r.b)("h3",{id:"awk"},"AWK"),Object(r.b)("p",null,"Benthos has an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/awk"}),"AWK processor"),", and since this is a proper programming language it has uses far beyond mapping. However, this also makes it riskier to use for large and complex maps. More opportunities to write bugs, more opportunities to break your program, more opportunities to regress."),Object(r.b)("p",null,"A simpler language specifically designed for mappings is a much more scalable solution as it reduces the opportunities for mistakes as both maps and teams grow. Although, risk aside, the major problem with using AWK within Benthos is the performance hit."),Object(r.b)("h3",{id:"json-processor"},"JSON Processor"),Object(r.b)("p",null,"The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/components/processors/json"}),"JSON processor")," is pretty flexible and would be the highest performer of all options here. However, beyond one or two mutations a mapping becomes an absolute mess of YAML, and if we need to add conditional maps into the mix it becomes much worse."),Object(r.b)("p",null,"It has been clear to me for a while that this processor is so quickly and easily outgrown by a typical user config that it perhaps ought to be entirely replaced with a real mapping solution."),Object(r.b)("h3",{id:"idml"},"IDML"),Object(r.b)("p",null,"If I could run ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://idml.io/"}),"IDML")," natively from Benthos then Bloblang wouldn't be happening. In my opinion ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://idml.io/"}),"IDML")," is a criminally underused technology and absolutely nails the issue of mapping data at scale."),Object(r.b)("p",null,"Similar to JMESPath the language itself doesn't have a concept of metadata, or querying across multiple documents (a batch). The issue I had here was that if I were going to go through the trouble of implementing IDML in Go I might as well add metadata and cross-batch querying, making it a different language anyway."),Object(r.b)("p",null,"However, I'm definitely writing Bloblang with IDML in mind, and if I manage to reach feature parity with IDML then I intend to break it out into its own lib and offer it to the org, with my Bloblang extensions as Benthos specific plugins."),Object(r.b)("h2",{id:"features"},"Features"),Object(r.b)("p",null,'So with that in mind what does Bloblang look like? Right now we only have queries, which is the "right hand side" of a mapping. These queries support literals:'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'"string literal"\ntrue\n93435.45\n')),Object(r.b)("p",null,"And arithmetic:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'50 + 34\n("this" == "that") || ("that" == "that")\n')),Object(r.b)("p",null,"And functions:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'json("foo.bar.baz")\nmeta("kafka_key")\ntimestamp_unix()\n')),Object(r.b)("p",null,"And methods, which are attached to a function or value:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'json("foo.bar.baz").from_all().sum()\n')),Object(r.b)("p",null,"And path literals with coalescing:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"json().foo.(bar | something_else).baz\n")),Object(r.b)("h2",{id:"next-steps"},"Next Steps"),Object(r.b)("p",null,"In terms of core syntaxes Bloblang is basically complete. It's implemented using parser combinators, and is very easy for me to extend with new functions and methods. Soon I'll expand Bloblang to support left hand query targets, which is when it really becomes a mapping language. It'll look something like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'pipeline:\n  processors:\n  - bloblang:\n      mapping: |\n        json.foo.bar = json().(something + another.thing)\n        json.and_this = meta("kafka_key").base64()\n')),Object(r.b)("p",null,"And I'll also add a ",Object(r.b)("inlineCode",{parentName:"p"},"condition")," type for expressing logic as a Bloblang query:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'pipeline:\n  processors:\n  - filter_parts:\n      bloblang:\n        query: |\n          (meta("kafka_topic") == "junk") &&\n            json().foo.(bar | baz.quz).id.contains("blah")\n')),Object(r.b)("p",null,"Until I'm allowed to practice with my professional rock paper scissors team again I'm sure each weekend will deliver something new to the world of Bloblang."))}c.isMDXComponent=!0},411:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=o.a.createContext({}),c=function(e){var t=o.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=c(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},h=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),b=c(n),h=a,m=b["".concat(i,".").concat(h)]||b[h]||u[h]||r;return n?o.a.createElement(m,s(s({ref:t},p),{},{components:n})):o.a.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);